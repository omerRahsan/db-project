--What about the partial search?
--We use LIKE and % (WILD CARD)
--% can represent 0 or more character of any kind
-- _ can represent exactly one character of any kind

/*

       'D%'   --- anything that starts with D
               David, Danny, Dog
       '%d'   --- anything that end with d
               Sid, Bid, Kid, Dad
       '%d%'   ---- anything that contains d
                 Aladdin, Cassandra, Adam, Brandon
                  David, Danny, Dog
                  Sid, Bid, Kid, Dad

       'D%a' ---- anything starts with D and end with a
                 Diana,  Donna, Damla

       'S%e%n' ---- any start with S , end with n , has e something in the middle
                Steven, Serkan, Stephen

       'T_' --- Starts with T and followed by exactly one character of any kind
                Tj , TD , T! , T2
       '_a_' --- starts with any character, followed by a
                 and followed by any one character

               Dad, Man , Fat, Tab, Gap
        */

SELECT FIRST_NAME FROM EMPLOYEES
--WHERE FIRST_NAME LIKE '%d%'
--WHERE FIRST_NAME LIKE '%D'
--WHERE FIRST_NAME LIKE '%d'
WHERE FIRST_NAME LIKE 'S%e%n';
--WHERE FIRST_NAME LIKE 'T_'
--WHERE FIRST_NAME LIKE '_a_ '


SELECT PHONE_NUMBER FROM EMPLOYEES
WHERE PHONE_NUMBER LIKE '515%';           --STARTING

SELECT PHONE_NUMBER FROM EMPLOYEES
WHERE PHONE_NUMBER LIKE '%.121.%';       --- IN THE MIDDLE



SELECT FIRST_NAME, SALARY AS MONEY ---KIND OF GIVING NICKNAME!(OPTIONALLY) TO COLUMN NAME!
FROM EMPLOYEES ;                    --- 'AS' KEYWORD

SELECT FIRST_NAME AS GIVEN_NAME, LAST_NAME AS "FAMILY NAME"
FROM EMPLOYEES;                   --"FAMILY NAME" IF it is more than  use quation marks
                       ---FAMILY_NAME ---ONE WORD!



--- CONCATENATION IN SQL USE DOUBLE PIPE || (THIS IS NOT OR)
--DISPLAY FIRST_NAME LAST_NAME, FULL_NAME FOR EMPLOYEE
SELECT FIRST_NAME, LAST_NAME,
        FIRST_NAME || ' ' || EMPLOYEES.LAST_NAME AS FULL_NAME
FROM EMPLOYEES;



--ARITHMETIC OPERATION : + - * /
SELECT FIRST_NAME, SALARY, SALARY+5000 AS INCREASED_SALARY
       FROM EMPLOYEES;

SELECT FIRST_NAME, SALARY,
       SALARY*12  AS YEARLY_SALARY,
    SALARY+5000 AS INCREASED_SALARY,
       SALARY/4 AS WEEKLY_SALARY
FROM EMPLOYEES;

---SQL BUILT IN FUNCTIONS:
---REUSABLE CODE THAT WRAPPED INTO FUNCTION FOR COMMON TASKS
---LIKE ROUNDING NUMBERS, GETTING LENGTH OF STR AND MORE
---SINGLE ROW FUNCTION:
       ---IT AFFECT EACH AND EVERY ROW AND RETURN SAME NUMBER OF ROW
       ---FEW TEXT FUNCTIONS:
       ---UPPER,
       ---LOWER,
       ---LENGTH,

SELECT  FIRST_NAME, UPPER(FIRST_NAME)
    FROM EMPLOYEES;

SELECT  FIRST_NAME, LENGTH(FIRST_NAME)
        ,LOWER(FIRST_NAME)
FROM EMPLOYEES;



SELECT FIRST_NAME FROM EMPLOYEES WHERE LENGTH(FIRST_NAME)  = 5;

SELECT FIRST_NAME, LENGTH(FIRST_NAME) FROM EMPLOYEES
WHERE  LENGTH(FIRST_NAME) BETWEEN 7 AND 9;


SELECT FIRST_NAME FROM EMPLOYEES
WHERE  LENGTH(FIRST_NAME) NOT BETWEEN 7 AND 9;

SELECT FIRST_NAME, LENGTH(FIRST_NAME) FROM EMPLOYEES
WHERE  LENGTH(FIRST_NAME) IN (2,9,11);


SELECT DISTINCT FIRST_NAME FROM EMPLOYEES
 --WHERE FIRST_NAME LIKE '%D%' OR FIRST_NAME LIKE '%d%';
 --WHERE UPPER(FIRST_NAME) LIKE '%D%';
   WHERE LOWER(FIRST_NAME) LIKE '%d%';


---Number functions:
---Round (decimal number here) ----> rounded number
----round (decimal number here, digit you wanna keep)---> rounded number with desired digit

SELECT SALARY,
       ROUND(SALARY/30),
       ROUND(SALARY/30 , 5)
FROM EMPLOYEES;



SELECT FIRST_NAME
FROM EMPLOYEES
ORDER BY LENGTH(FIRST_NAME);
--ORDER BY LENGTH(FIRST_NAME) DESC





-----MULTI ROW | GROUP | AGGREGATE FUNCTIONS

---COUNT * OR BY COLUMN NAME

SELECT COUNT(*), COUNT(FIRST_NAME)
FROM EMPLOYEES;



-----NULL VALUES CAN NOT BE COUNTED!!!!!

SELECT COUNT(*)
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 90;

---MAX
-----FIND OUT THE MAX SALARY IN EMPLOYEES

SELECT MAX(SALARY)
FROM EMPLOYEES;


SELECT MAX(SALARY)
FROM EMPLOYEES
WHERE SALARY != 24000;   ----   '<>';

SELECT MIN(SALARY)
FROM EMPLOYEES
WHERE SALARY <> 2100;

SELECT SUM(SALARY)
FROM EMPLOYEES;


SELECT SUM(SALARY)
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 90;

SELECT ROUND(AVG(SALARY) )
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 90;

----ALL IN ONE SHOT
SELECT COUNT(*) AS "EMPLOYEE COUNT",
       MAX(SALARY) AS "HIGHEST SALARY",
       MIN(SALARY) AS "LOWEST SALARY",
       SUM(SALARY) AS "SUM OF ALL SALARY",
       AVG(SALARY) AS "AVERAGE SALARY"
       FROM EMPLOYEES;


----- GROUP BY

----- DISPLAY COUNT OF EMPLOYEES IN EACH DEPARTMENT

SELECT DEPARTMENT_ID, COUNT(*) AS "DEP_EMP_COUNT "
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

----DISPLAY COUNT OF EMPLOYEES IN EACH JOB_ID

SELECT JOB_ID, COUNT(*)
FROM EMPLOYEES
GROUP BY JOB_ID;

---DISPLAY THE MAX SALARY FOR EACH DEPARTMENT
---DISPLAY THE AVG SALARY FOR EACH DEPARTMENT
---DISPLAY THE SUM SALARY FOR EACH DEPARTMENT


SELECT DEPARTMENT_ID, MAX(SALARY) AS "HIGHEST SALARY",
  ROUND(AVG(SALARY)) AS "AVERAGE SALARY" , SUM(SALARY) AS "ALL SALARY"
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;


 SELECT REGION_ID, COUNT(REGION_ID) AS "COUNT OF COUNTRIES"
FROM COUNTRIES
GROUP BY REGION_ID;

----WHEN YOU HEARD "EACH" ----->>>>> USE GROUP BY !!!!
--- GROUP BY CAN BE USED ALONG WITH MULTI-ROW(AGGREGATE, GROUP) FUNCTIONS
---TO GENERATE RESULT PER GROUP INSTEAD OF WHOLE TABLE
---IT CAN ONLY BE USED ALONG WITH MULTI-ROW FUNCTIONS


------------------<-------------------------------------->>---------------


----HAVING CAN BE USED AFTER GROUP BY TO FILTER
---ALREADY COMBINED RESULT FURTHER MORE

SELECT DEPARTMENT_ID, COUNT(*)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING COUNT(*) > 10;


----- YOU CAN ONLY USE HAVING IF YOU ARE USING AGGREGATE FUNCTIONS IN CONDITION AFTER GROUP BY!

SELECT DEPARTMENT_ID, MAX(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING MAX(SALARY) > 10000 AND DEPARTMENT_ID <100;


SELECT DEPARTMENT_ID, MAX(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING DEPARTMENT_ID != 100;
--OR WHERE DEPARTMENT_ID != 100

---- !!!!!!!! FOR AGGREGATE FUNCTIONS (MAX,MIN,SUM) YOU CAN ONLY
----USE HAVING BUT FOR OTHERS YOU CAN USE BOTH- HAVING OR WHERE !!!!!!
























